!(function (t, e) {
  "object" == typeof exports && "undefined" != typeof module
    ? (module.exports = e())
    : "function" == typeof define && define.amd
    ? define(e)
    : ((t =
        "undefined" != typeof globalThis ? globalThis : t || self).bootstrap =
        e());
})(this, function () {
  "use strict";
  let t = "transitionend",
    e = (t) =>
      null == t
        ? `${t}`
        : {}.toString
            .call(t)
            .match(/\s([a-z]+)/i)[1]
            .toLowerCase(),
    i = (t) => {
      do t += Math.floor(1e6 * Math.random());
      while (document.getElementById(t));
      return t;
    },
    s = (t) => {
      let e = t.getAttribute("data-bs-target");
      if (!e || "#" === e) {
        let i = t.getAttribute("href");
        if (!i || (!i.includes("#") && !i.startsWith("."))) return null;
        i.includes("#") && !i.startsWith("#") && (i = `#${i.split("#")[1]}`),
          (e = i && "#" !== i ? i.trim() : null);
      }
      return e;
    },
    n = (t) => {
      let e = s(t);
      return e && document.querySelector(e) ? e : null;
    },
    o = (t) => {
      let e = s(t);
      return e ? document.querySelector(e) : null;
    },
    r = (t) => {
      if (!t) return 0;
      let { transitionDuration: e, transitionDelay: i } =
          window.getComputedStyle(t),
        s = Number.parseFloat(e),
        n = Number.parseFloat(i);
      return s || n
        ? ((e = e.split(",")[0]),
          (i = i.split(",")[0]),
          (Number.parseFloat(e) + Number.parseFloat(i)) * 1e3)
        : 0;
    },
    l = (e) => {
      e.dispatchEvent(new Event(t));
    },
    a = (t) =>
      !!t &&
      "object" == typeof t &&
      (void 0 !== t.jquery && (t = t[0]), void 0 !== t.nodeType),
    h = (t) =>
      a(t)
        ? t.jquery
          ? t[0]
          : t
        : "string" == typeof t && t.length > 0
        ? document.querySelector(t)
        : null,
    c = (t, i, s) => {
      Object.keys(s).forEach((n) => {
        let o = s[n],
          r = i[n],
          l = r && a(r) ? "element" : e(r);
        if (!RegExp(o).test(l))
          throw TypeError(
            `${t.toUpperCase()}: Option "${n}" provided type "${l}" but expected type "${o}".`
          );
      });
    },
    d = (t) =>
      !!a(t) &&
      0 !== t.getClientRects().length &&
      "visible" === getComputedStyle(t).getPropertyValue("visibility"),
    u = (t) =>
      !!(
        !t ||
        t.nodeType !== Node.ELEMENT_NODE ||
        t.classList.contains("disabled")
      ) ||
      (void 0 !== t.disabled
        ? t.disabled
        : t.hasAttribute("disabled") && "false" !== t.getAttribute("disabled")),
    g = (t) => {
      if (!document.documentElement.attachShadow) return null;
      if ("function" == typeof t.getRootNode) {
        let e = t.getRootNode();
        return e instanceof ShadowRoot ? e : null;
      }
      return t instanceof ShadowRoot
        ? t
        : t.parentNode
        ? g(t.parentNode)
        : null;
    },
    f = () => {},
    m = (t) => {
      t.offsetHeight;
    },
    p = () => {
      let { jQuery: t } = window;
      return t && !document.body.hasAttribute("data-bs-no-jquery") ? t : null;
    },
    v = [],
    b = (t) => {
      "loading" === document.readyState
        ? (v.length ||
            document.addEventListener("DOMContentLoaded", () => {
              v.forEach((t) => t());
            }),
          v.push(t))
        : t();
    },
    E = () => "rtl" === document.documentElement.dir,
    y = (t) => {
      b(() => {
        let e = p();
        if (e) {
          let i = t.NAME,
            s = e.fn[i];
          (e.fn[i] = t.jQueryInterface),
            (e.fn[i].Constructor = t),
            (e.fn[i].noConflict = () => ((e.fn[i] = s), t.jQueryInterface));
        }
      });
    },
    A = (t) => {
      "function" == typeof t && t();
    },
    w = (e, i, s = !0) => {
      if (!s) {
        A(e);
        return;
      }
      let n = r(i) + 5,
        o = !1,
        a = ({ target: s }) => {
          s === i && ((o = !0), i.removeEventListener(t, a), A(e));
        };
      i.addEventListener(t, a),
        setTimeout(() => {
          o || l(i);
        }, n);
    },
    T = (t, e, i, s) => {
      let n = t.indexOf(e);
      if (-1 === n) return t[!i && s ? t.length - 1 : 0];
      let o = t.length;
      return (
        (n += i ? 1 : -1),
        s && (n = (n + o) % o),
        t[Math.max(0, Math.min(n, o - 1))]
      );
    },
    $ = /[^.]*(?=\..*)\.|.*/,
    C = /\..*/,
    k = /::\d+$/,
    L = {},
    S = 1,
    I = { mouseenter: "mouseover", mouseleave: "mouseout" },
    O = /^(mouseenter|mouseleave)/i,
    D = new Set([
      "click",
      "dblclick",
      "mouseup",
      "mousedown",
      "contextmenu",
      "mousewheel",
      "DOMMouseScroll",
      "mouseover",
      "mouseout",
      "mousemove",
      "selectstart",
      "selectend",
      "keydown",
      "keypress",
      "keyup",
      "orientationchange",
      "touchstart",
      "touchmove",
      "touchend",
      "touchcancel",
      "pointerdown",
      "pointermove",
      "pointerup",
      "pointerleave",
      "pointercancel",
      "gesturestart",
      "gesturechange",
      "gestureend",
      "focus",
      "blur",
      "change",
      "reset",
      "select",
      "submit",
      "focusin",
      "focusout",
      "load",
      "unload",
      "beforeunload",
      "resize",
      "move",
      "DOMContentLoaded",
      "readystatechange",
      "error",
      "abort",
      "scroll",
    ]);
  function N(t, e) {
    return (e && `${e}::${S++}`) || t.uidEvent || S++;
  }
  function _(t) {
    let e = N(t);
    return (t.uidEvent = e), (L[e] = L[e] || {}), L[e];
  }
  function x(t, e, i = null) {
    let s = Object.keys(t);
    for (let n = 0, o = s.length; n < o; n++) {
      let r = t[s[n]];
      if (r.originalHandler === e && r.delegationSelector === i) return r;
    }
    return null;
  }
  function P(t, e, i) {
    let s = "string" == typeof e,
      n = j(t),
      o = D.has(n);
    return o || (n = t), [s, s ? i : e, n];
  }
  function M(t, e, i, s, n) {
    var o, r, l, a, h;
    if ("string" != typeof e || !t) return;
    if ((i || ((i = s), (s = null)), O.test(e))) {
      let c = (t) =>
        function (e) {
          if (
            !e.relatedTarget ||
            (e.relatedTarget !== e.delegateTarget &&
              !e.delegateTarget.contains(e.relatedTarget))
          )
            return t.call(this, e);
        };
      s ? (s = c(s)) : (i = c(i));
    }
    let [d, u, g] = P(e, i, s),
      f = _(t),
      m = f[g] || (f[g] = {}),
      p = x(m, u, d ? i : null);
    if (p) {
      p.oneOff = p.oneOff && n;
      return;
    }
    let v = N(u, e.replace($, "")),
      b = d
        ? ((o = t),
          (r = i),
          (l = s),
          function t(e) {
            let i = o.querySelectorAll(r);
            for (let { target: s } = e; s && s !== this; s = s.parentNode)
              for (let n = i.length; n--; )
                if (i[n] === s)
                  return (
                    (e.delegateTarget = s),
                    t.oneOff && z.off(o, e.type, r, l),
                    l.apply(s, [e])
                  );
            return null;
          })
        : ((a = t),
          (h = i),
          function t(e) {
            return (
              (e.delegateTarget = a),
              t.oneOff && z.off(a, e.type, h),
              h.apply(a, [e])
            );
          });
    (b.delegationSelector = d ? i : null),
      (b.originalHandler = u),
      (b.oneOff = n),
      (b.uidEvent = v),
      (m[v] = b),
      t.addEventListener(g, b, d);
  }
  function H(t, e, i, s, n) {
    let o = x(e[i], s, n);
    o && (t.removeEventListener(i, o, Boolean(n)), delete e[i][o.uidEvent]);
  }
  function j(t) {
    return I[(t = t.replace(C, ""))] || t;
  }
  let z = {
      on(t, e, i, s) {
        M(t, e, i, s, !1);
      },
      one(t, e, i, s) {
        M(t, e, i, s, !0);
      },
      off(t, e, i, s) {
        if ("string" != typeof e || !t) return;
        let [n, o, r] = P(e, i, s),
          l = r !== e,
          a = _(t),
          h = e.startsWith(".");
        if (void 0 !== o) {
          if (!a || !a[r]) return;
          H(t, a, r, o, n ? i : null);
          return;
        }
        h &&
          Object.keys(a).forEach((i) => {
            !(function t(e, i, s, n) {
              let o = i[s] || {};
              Object.keys(o).forEach((t) => {
                if (t.includes(n)) {
                  let r = o[t];
                  H(e, i, s, r.originalHandler, r.delegationSelector);
                }
              });
            })(t, a, i, e.slice(1));
          });
        let c = a[r] || {};
        Object.keys(c).forEach((i) => {
          let s = i.replace(k, "");
          if (!l || e.includes(s)) {
            let n = c[i];
            H(t, a, r, n.originalHandler, n.delegationSelector);
          }
        });
      },
      trigger(t, e, i) {
        if ("string" != typeof e || !t) return null;
        let s = p(),
          n = j(e),
          o = D.has(n),
          r,
          l = !0,
          a = !0,
          h = !1,
          c = null;
        return (
          e !== n &&
            s &&
            ((r = s.Event(e, i)),
            s(t).trigger(r),
            (l = !r.isPropagationStopped()),
            (a = !r.isImmediatePropagationStopped()),
            (h = r.isDefaultPrevented())),
          o
            ? (c = document.createEvent("HTMLEvents")).initEvent(n, l, !0)
            : (c = new CustomEvent(e, { bubbles: l, cancelable: !0 })),
          void 0 !== i &&
            Object.keys(i).forEach((t) => {
              Object.defineProperty(c, t, { get: () => i[t] });
            }),
          h && c.preventDefault(),
          a && t.dispatchEvent(c),
          c.defaultPrevented && void 0 !== r && r.preventDefault(),
          c
        );
      },
    },
    B = new Map(),
    F = {
      set(t, e, i) {
        B.has(t) || B.set(t, new Map());
        let s = B.get(t);
        if (!s.has(e) && 0 !== s.size) {
          console.error(
            `Bootstrap doesn't allow more than one instance per element. Bound instance: ${
              Array.from(s.keys())[0]
            }.`
          );
          return;
        }
        s.set(e, i);
      },
      get: (t, e) => (B.has(t) && B.get(t).get(e)) || null,
      remove(t, e) {
        if (!B.has(t)) return;
        let i = B.get(t);
        i.delete(e), 0 === i.size && B.delete(t);
      },
    };
  class W {
    constructor(t) {
      if (!(t = h(t))) return;
      (this._element = t),
        F.set(this._element, this.constructor.DATA_KEY, this);
    }
    dispose() {
      F.remove(this._element, this.constructor.DATA_KEY),
        z.off(this._element, this.constructor.EVENT_KEY),
        Object.getOwnPropertyNames(this).forEach((t) => {
          this[t] = null;
        });
    }
    _queueCallback(t, e, i = !0) {
      w(t, e, i);
    }
    static getInstance(t) {
      return F.get(h(t), this.DATA_KEY);
    }
    static getOrCreateInstance(t, e = {}) {
      return (
        this.getInstance(t) || new this(t, "object" == typeof e ? e : null)
      );
    }
    static get VERSION() {
      return "5.1.3";
    }
    static get NAME() {
      throw Error(
        'You have to implement the static method "NAME", for each component!'
      );
    }
    static get DATA_KEY() {
      return `bs.${this.NAME}`;
    }
    static get EVENT_KEY() {
      return `.${this.DATA_KEY}`;
    }
  }
  let R = (t, e = "hide") => {
      let i = `click.dismiss${t.EVENT_KEY}`,
        s = t.NAME;
      z.on(document, i, `[data-bs-dismiss="${s}"]`, function (i) {
        if (
          (["A", "AREA"].includes(this.tagName) && i.preventDefault(), u(this))
        )
          return;
        let n = o(this) || this.closest(`.${s}`),
          r = t.getOrCreateInstance(n);
        r[e]();
      });
    },
    q = ".bs.alert",
    U = `close${q}`,
    K = `closed${q}`;
  class V extends W {
    static get NAME() {
      return "alert";
    }
    close() {
      let t = z.trigger(this._element, U);
      if (t.defaultPrevented) return;
      this._element.classList.remove("show");
      let e = this._element.classList.contains("fade");
      this._queueCallback(() => this._destroyElement(), this._element, e);
    }
    _destroyElement() {
      this._element.remove(), z.trigger(this._element, K), this.dispose();
    }
    static jQueryInterface(t) {
      return this.each(function () {
        let e = V.getOrCreateInstance(this);
        if ("string" == typeof t) {
          if (void 0 === e[t] || t.startsWith("_") || "constructor" === t)
            throw TypeError(`No method named "${t}"`);
          e[t](this);
        }
      });
    }
  }
  R(V, "close"), y(V);
  let X = '[data-bs-toggle="button"]',
    Y = "click.bs.button.data-api";
  class Q extends W {
    static get NAME() {
      return "button";
    }
    toggle() {
      this._element.setAttribute(
        "aria-pressed",
        this._element.classList.toggle("active")
      );
    }
    static jQueryInterface(t) {
      return this.each(function () {
        let e = Q.getOrCreateInstance(this);
        "toggle" === t && e[t]();
      });
    }
  }
  function G(t) {
    return (
      "true" === t ||
      ("false" !== t &&
        (t === Number(t).toString()
          ? Number(t)
          : "" === t || "null" === t
          ? null
          : t))
    );
  }
  function Z(t) {
    return t.replace(/[A-Z]/g, (t) => `-${t.toLowerCase()}`);
  }
  z.on(document, Y, X, (t) => {
    t.preventDefault();
    let e = t.target.closest(X),
      i = Q.getOrCreateInstance(e);
    i.toggle();
  }),
    y(Q);
  let J = {
      setDataAttribute(t, e, i) {
        t.setAttribute(`data-bs-${Z(e)}`, i);
      },
      removeDataAttribute(t, e) {
        t.removeAttribute(`data-bs-${Z(e)}`);
      },
      getDataAttributes(t) {
        if (!t) return {};
        let e = {};
        return (
          Object.keys(t.dataset)
            .filter((t) => t.startsWith("bs"))
            .forEach((i) => {
              let s = i.replace(/^bs/, "");
              e[(s = s.charAt(0).toLowerCase() + s.slice(1, s.length))] = G(
                t.dataset[i]
              );
            }),
          e
        );
      },
      getDataAttribute: (t, e) => G(t.getAttribute(`data-bs-${Z(e)}`)),
      offset(t) {
        let e = t.getBoundingClientRect();
        return {
          top: e.top + window.pageYOffset,
          left: e.left + window.pageXOffset,
        };
      },
      position: (t) => ({ top: t.offsetTop, left: t.offsetLeft }),
    },
    tt = {
      find: (t, e = document.documentElement) =>
        [].concat(...Element.prototype.querySelectorAll.call(e, t)),
      findOne: (t, e = document.documentElement) =>
        Element.prototype.querySelector.call(e, t),
      children: (t, e) => [].concat(...t.children).filter((t) => t.matches(e)),
      parents(t, e) {
        let i = [],
          s = t.parentNode;
        for (; s && s.nodeType === Node.ELEMENT_NODE && 3 !== s.nodeType; )
          s.matches(e) && i.push(s), (s = s.parentNode);
        return i;
      },
      prev(t, e) {
        let i = t.previousElementSibling;
        for (; i; ) {
          if (i.matches(e)) return [i];
          i = i.previousElementSibling;
        }
        return [];
      },
      next(t, e) {
        let i = t.nextElementSibling;
        for (; i; ) {
          if (i.matches(e)) return [i];
          i = i.nextElementSibling;
        }
        return [];
      },
      focusableChildren(t) {
        let e = [
          "a",
          "button",
          "input",
          "textarea",
          "select",
          "details",
          "[tabindex]",
          '[contenteditable="true"]',
        ]
          .map((t) => `${t}:not([tabindex^="-"])`)
          .join(", ");
        return this.find(e, t).filter((t) => !u(t) && d(t));
      },
    },
    te = "carousel",
    ti = ".bs.carousel",
    ts = ".data-api",
    tn = {
      interval: 5e3,
      keyboard: !0,
      slide: !1,
      pause: "hover",
      wrap: !0,
      touch: !0,
    },
    to = {
      interval: "(number|boolean)",
      keyboard: "boolean",
      slide: "(boolean|string)",
      pause: "(string|boolean)",
      wrap: "boolean",
      touch: "boolean",
    },
    tr = "next",
    tl = "prev",
    ta = "left",
    th = "right",
    tc = { ArrowLeft: th, ArrowRight: ta },
    td = `slide${ti}`,
    tu = `slid${ti}`,
    t8 = `keydown${ti}`,
    tg = `mouseenter${ti}`,
    tf = `mouseleave${ti}`,
    tm = `touchstart${ti}`,
    tp = `touchmove${ti}`,
    tv = `touchend${ti}`,
    tb = `pointerdown${ti}`,
    tE = `pointerup${ti}`,
    ty = `dragstart${ti}`,
    tA = `load${ti}${ts}`,
    tw = `click${ti}${ts}`,
    tT = "active",
    t$ = ".active.carousel-item";
  class tC extends W {
    constructor(t, e) {
      super(t),
        (this._items = null),
        (this._interval = null),
        (this._activeElement = null),
        (this._isPaused = !1),
        (this._isSliding = !1),
        (this.touchTimeout = null),
        (this.touchStartX = 0),
        (this.touchDeltaX = 0),
        (this._config = this._getConfig(e)),
        (this._indicatorsElement = tt.findOne(
          ".carousel-indicators",
          this._element
        )),
        (this._touchSupported =
          "ontouchstart" in document.documentElement ||
          navigator.maxTouchPoints > 0),
        (this._pointerEvent = Boolean(window.PointerEvent)),
        this._addEventListeners();
    }
    static get Default() {
      return tn;
    }
    static get NAME() {
      return te;
    }
    next() {
      this._slide(tr);
    }
    nextWhenVisible() {
      !document.hidden && d(this._element) && this.next();
    }
    prev() {
      this._slide(tl);
    }
    pause(t) {
      t || (this._isPaused = !0),
        tt.findOne(".carousel-item-next, .carousel-item-prev", this._element) &&
          (l(this._element), this.cycle(!0)),
        clearInterval(this._interval),
        (this._interval = null);
    }
    cycle(t) {
      t || (this._isPaused = !1),
        this._interval &&
          (clearInterval(this._interval), (this._interval = null)),
        this._config &&
          this._config.interval &&
          !this._isPaused &&
          (this._updateInterval(),
          (this._interval = setInterval(
            (document.visibilityState ? this.nextWhenVisible : this.next).bind(
              this
            ),
            this._config.interval
          )));
    }
    to(t) {
      this._activeElement = tt.findOne(t$, this._element);
      let e = this._getItemIndex(this._activeElement);
      if (!(t > this._items.length - 1) && !(t < 0)) {
        if (this._isSliding) {
          z.one(this._element, tu, () => this.to(t));
          return;
        }
        if (e === t) {
          this.pause(), this.cycle();
          return;
        }
        this._slide(t > e ? tr : tl, this._items[t]);
      }
    }
    _getConfig(t) {
      return (
        c(
          te,
          (t = {
            ...tn,
            ...J.getDataAttributes(this._element),
            ...("object" == typeof t ? t : {}),
          }),
          to
        ),
        t
      );
    }
    _handleSwipe() {
      let t = Math.abs(this.touchDeltaX);
      if (t <= 40) return;
      let e = t / this.touchDeltaX;
      (this.touchDeltaX = 0), e && this._slide(e > 0 ? th : ta);
    }
    _addEventListeners() {
      this._config.keyboard && z.on(this._element, t8, (t) => this._keydown(t)),
        "hover" === this._config.pause &&
          (z.on(this._element, tg, (t) => this.pause(t)),
          z.on(this._element, tf, (t) => this.cycle(t))),
        this._config.touch &&
          this._touchSupported &&
          this._addTouchEventListeners();
    }
    _addTouchEventListeners() {
      let t = (t) =>
          this._pointerEvent &&
          ("pen" === t.pointerType || "touch" === t.pointerType),
        e = (e) => {
          t(e)
            ? (this.touchStartX = e.clientX)
            : this._pointerEvent || (this.touchStartX = e.touches[0].clientX);
        },
        i = (t) => {
          this.touchDeltaX =
            t.touches && t.touches.length > 1
              ? 0
              : t.touches[0].clientX - this.touchStartX;
        },
        s = (e) => {
          t(e) && (this.touchDeltaX = e.clientX - this.touchStartX),
            this._handleSwipe(),
            "hover" === this._config.pause &&
              (this.pause(),
              this.touchTimeout && clearTimeout(this.touchTimeout),
              (this.touchTimeout = setTimeout(
                (t) => this.cycle(t),
                500 + this._config.interval
              )));
        };
      tt.find(".carousel-item img", this._element).forEach((t) => {
        z.on(t, ty, (t) => t.preventDefault());
      }),
        this._pointerEvent
          ? (z.on(this._element, tb, (t) => e(t)),
            z.on(this._element, tE, (t) => s(t)),
            this._element.classList.add("pointer-event"))
          : (z.on(this._element, tm, (t) => e(t)),
            z.on(this._element, tp, (t) => i(t)),
            z.on(this._element, tv, (t) => s(t)));
    }
    _keydown(t) {
      if (/input|textarea/i.test(t.target.tagName)) return;
      let e = tc[t.key];
      e && (t.preventDefault(), this._slide(e));
    }
    _getItemIndex(t) {
      return (
        (this._items =
          t && t.parentNode ? tt.find(".carousel-item", t.parentNode) : []),
        this._items.indexOf(t)
      );
    }
    _getItemByOrder(t, e) {
      return T(this._items, e, t === tr, this._config.wrap);
    }
    _triggerSlideEvent(t, e) {
      let i = this._getItemIndex(t),
        s = this._getItemIndex(tt.findOne(t$, this._element));
      return z.trigger(this._element, td, {
        relatedTarget: t,
        direction: e,
        from: s,
        to: i,
      });
    }
    _setActiveIndicatorElement(t) {
      if (this._indicatorsElement) {
        let e = tt.findOne(".active", this._indicatorsElement);
        e.classList.remove(tT), e.removeAttribute("aria-current");
        let i = tt.find("[data-bs-target]", this._indicatorsElement);
        for (let s = 0; s < i.length; s++)
          if (
            Number.parseInt(i[s].getAttribute("data-bs-slide-to"), 10) ===
            this._getItemIndex(t)
          ) {
            i[s].classList.add(tT), i[s].setAttribute("aria-current", "true");
            break;
          }
      }
    }
    _updateInterval() {
      let t = this._activeElement || tt.findOne(t$, this._element);
      if (!t) return;
      let e = Number.parseInt(t.getAttribute("data-bs-interval"), 10);
      e
        ? ((this._config.defaultInterval =
            this._config.defaultInterval || this._config.interval),
          (this._config.interval = e))
        : (this._config.interval =
            this._config.defaultInterval || this._config.interval);
    }
    _slide(t, e) {
      let i = this._directionToOrder(t),
        s = tt.findOne(t$, this._element),
        n = this._getItemIndex(s),
        o = e || this._getItemByOrder(i, s),
        r = this._getItemIndex(o),
        l = Boolean(this._interval),
        a = i === tr,
        h = a ? "carousel-item-start" : "carousel-item-end",
        c = a ? "carousel-item-next" : "carousel-item-prev",
        d = this._orderToDirection(i);
      if (o && o.classList.contains(tT)) {
        this._isSliding = !1;
        return;
      }
      if (this._isSliding) return;
      let u = this._triggerSlideEvent(o, d);
      if (u.defaultPrevented || !s || !o) return;
      (this._isSliding = !0),
        l && this.pause(),
        this._setActiveIndicatorElement(o),
        (this._activeElement = o);
      let g = () => {
        z.trigger(this._element, tu, {
          relatedTarget: o,
          direction: d,
          from: n,
          to: r,
        });
      };
      if (this._element.classList.contains("slide")) {
        o.classList.add(c), m(o), s.classList.add(h), o.classList.add(h);
        let f = () => {
          o.classList.remove(h, c),
            o.classList.add(tT),
            s.classList.remove(tT, c, h),
            (this._isSliding = !1),
            setTimeout(g, 0);
        };
        this._queueCallback(f, s, !0);
      } else s.classList.remove(tT), o.classList.add(tT), (this._isSliding = !1), g();
      l && this.cycle();
    }
    _directionToOrder(t) {
      return [th, ta].includes(t)
        ? E()
          ? t === ta
            ? tl
            : tr
          : t === ta
          ? tr
          : tl
        : t;
    }
    _orderToDirection(t) {
      return [tr, tl].includes(t)
        ? E()
          ? t === tl
            ? ta
            : th
          : t === tl
          ? th
          : ta
        : t;
    }
    static carouselInterface(t, e) {
      let i = tC.getOrCreateInstance(t, e),
        { _config: s } = i;
      "object" == typeof e && (s = { ...s, ...e });
      let n = "string" == typeof e ? e : s.slide;
      if ("number" == typeof e) i.to(e);
      else if ("string" == typeof n) {
        if (void 0 === i[n]) throw TypeError(`No method named "${n}"`);
        i[n]();
      } else s.interval && s.ride && (i.pause(), i.cycle());
    }
    static jQueryInterface(t) {
      return this.each(function () {
        tC.carouselInterface(this, t);
      });
    }
    static dataApiClickHandler(t) {
      let e = o(this);
      if (!e || !e.classList.contains("carousel")) return;
      let i = { ...J.getDataAttributes(e), ...J.getDataAttributes(this) },
        s = this.getAttribute("data-bs-slide-to");
      s && (i.interval = !1),
        tC.carouselInterface(e, i),
        s && tC.getInstance(e).to(s),
        t.preventDefault();
    }
  }
  z.on(
    document,
    tw,
    "[data-bs-slide], [data-bs-slide-to]",
    tC.dataApiClickHandler
  ),
    z.on(window, tA, () => {
      let t = tt.find('[data-bs-ride="carousel"]');
      for (let e = 0, i = t.length; e < i; e++)
        tC.carouselInterface(t[e], tC.getInstance(t[e]));
    }),
    y(tC);
  let tk = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top",
    t9 = ".sticky-top";
  class tL {
    constructor() {
      this._element = document.body;
    }
    getWidth() {
      let t = document.documentElement.clientWidth;
      return Math.abs(window.innerWidth - t);
    }
    hide() {
      let t = this.getWidth();
      this._disableOverFlow(),
        this._setElementAttributes(this._element, "paddingRight", (e) => e + t),
        this._setElementAttributes(tk, "paddingRight", (e) => e + t),
        this._setElementAttributes(t9, "marginRight", (e) => e - t);
    }
    _disableOverFlow() {
      this._saveInitialAttribute(this._element, "overflow"),
        (this._element.style.overflow = "hidden");
    }
    _setElementAttributes(t, e, i) {
      let s = this.getWidth(),
        n = (t) => {
          if (t !== this._element && window.innerWidth > t.clientWidth + s)
            return;
          this._saveInitialAttribute(t, e);
          let n = window.getComputedStyle(t)[e];
          t.style[e] = `${i(Number.parseFloat(n))}px`;
        };
      this._applyManipulationCallback(t, n);
    }
    reset() {
      this._resetElementAttributes(this._element, "overflow"),
        this._resetElementAttributes(this._element, "paddingRight"),
        this._resetElementAttributes(tk, "paddingRight"),
        this._resetElementAttributes(t9, "marginRight");
    }
    _saveInitialAttribute(t, e) {
      let i = t.style[e];
      i && J.setDataAttribute(t, e, i);
    }
    _resetElementAttributes(t, e) {
      let i = (t) => {
        let i = J.getDataAttribute(t, e);
        void 0 === i
          ? t.style.removeProperty(e)
          : (J.removeDataAttribute(t, e), (t.style[e] = i));
      };
      this._applyManipulationCallback(t, i);
    }
    _applyManipulationCallback(t, e) {
      a(t) ? e(t) : tt.find(t, this._element).forEach(e);
    }
    isOverflowing() {
      return this.getWidth() > 0;
    }
  }
  let tS = {
      className: "modal-backdrop",
      isVisible: !0,
      isAnimated: !1,
      rootElement: "body",
      clickCallback: null,
    },
    tI = {
      className: "string",
      isVisible: "boolean",
      isAnimated: "boolean",
      rootElement: "(element|string)",
      clickCallback: "(function|null)",
    },
    tO = "backdrop",
    tD = "show",
    tN = `mousedown.bs.${tO}`;
  class t_ {
    constructor(t) {
      (this._config = this._getConfig(t)),
        (this._isAppended = !1),
        (this._element = null);
    }
    show(t) {
      if (!this._config.isVisible) {
        A(t);
        return;
      }
      this._append(),
        this._config.isAnimated && m(this._getElement()),
        this._getElement().classList.add(tD),
        this._emulateAnimation(() => {
          A(t);
        });
    }
    hide(t) {
      if (!this._config.isVisible) {
        A(t);
        return;
      }
      this._getElement().classList.remove(tD),
        this._emulateAnimation(() => {
          this.dispose(), A(t);
        });
    }
    _getElement() {
      if (!this._element) {
        let t = document.createElement("div");
        (t.className = this._config.className),
          this._config.isAnimated && t.classList.add("fade"),
          (this._element = t);
      }
      return this._element;
    }
    _getConfig(t) {
      return (
        ((t = { ...tS, ...("object" == typeof t ? t : {}) }).rootElement = h(
          t.rootElement
        )),
        c(tO, t, tI),
        t
      );
    }
    _append() {
      !this._isAppended &&
        (this._config.rootElement.append(this._getElement()),
        z.on(this._getElement(), tN, () => {
          A(this._config.clickCallback);
        }),
        (this._isAppended = !0));
    }
    dispose() {
      this._isAppended &&
        (z.off(this._element, tN),
        this._element.remove(),
        (this._isAppended = !1));
    }
    _emulateAnimation(t) {
      w(t, this._getElement(), this._config.isAnimated);
    }
  }
  let tx = { trapElement: null, autofocus: !0 },
    tP = { trapElement: "element", autofocus: "boolean" },
    tM = ".bs.focustrap",
    tH = `focusin${tM}`,
    tj = `keydown.tab${tM}`,
    tz = "backward";
  class tB {
    constructor(t) {
      (this._config = this._getConfig(t)),
        (this._isActive = !1),
        (this._lastTabNavDirection = null);
    }
    activate() {
      let { trapElement: t, autofocus: e } = this._config;
      !this._isActive &&
        (e && t.focus(),
        z.off(document, tM),
        z.on(document, tH, (t) => this._handleFocusin(t)),
        z.on(document, tj, (t) => this._handleKeydown(t)),
        (this._isActive = !0));
    }
    deactivate() {
      this._isActive && ((this._isActive = !1), z.off(document, tM));
    }
    _handleFocusin(t) {
      let { target: e } = t,
        { trapElement: i } = this._config;
      if (e === document || e === i || i.contains(e)) return;
      let s = tt.focusableChildren(i);
      0 === s.length
        ? i.focus()
        : this._lastTabNavDirection === tz
        ? s[s.length - 1].focus()
        : s[0].focus();
    }
    _handleKeydown(t) {
      "Tab" === t.key &&
        (this._lastTabNavDirection = t.shiftKey ? tz : "forward");
    }
    _getConfig(t) {
      return (
        c("focustrap", (t = { ...tx, ...("object" == typeof t ? t : {}) }), tP),
        t
      );
    }
  }
  let tF = "modal",
    tW = ".bs.modal",
    tR = "Escape",
    tq = { backdrop: !0, keyboard: !0, focus: !0 },
    tU = {
      backdrop: "(boolean|string)",
      keyboard: "boolean",
      focus: "boolean",
    },
    tK = `hide${tW}`,
    tV = `hidePrevented${tW}`,
    tX = `hidden${tW}`,
    tY = `show${tW}`,
    tQ = `shown${tW}`,
    t1 = `resize${tW}`,
    t3 = `click.dismiss${tW}`,
    t2 = `keydown.dismiss${tW}`,
    t4 = `mouseup.dismiss${tW}`,
    tG = `mousedown.dismiss${tW}`,
    tZ = `click${tW}.data-api`,
    t0 = "modal-open",
    t6 = "show",
    tJ = "modal-static";
  class t5 extends W {
    constructor(t, e) {
      super(t),
        (this._config = this._getConfig(e)),
        (this._dialog = tt.findOne(".modal-dialog", this._element)),
        (this._backdrop = this._initializeBackDrop()),
        (this._focustrap = this._initializeFocusTrap()),
        (this._isShown = !1),
        (this._ignoreBackdropClick = !1),
        (this._isTransitioning = !1),
        (this._scrollBar = new tL());
    }
    static get Default() {
      return tq;
    }
    static get NAME() {
      return tF;
    }
    toggle(t) {
      return this._isShown ? this.hide() : this.show(t);
    }
    show(t) {
      if (this._isShown || this._isTransitioning) return;
      let e = z.trigger(this._element, tY, { relatedTarget: t });
      !e.defaultPrevented &&
        ((this._isShown = !0),
        this._isAnimated() && (this._isTransitioning = !0),
        this._scrollBar.hide(),
        document.body.classList.add(t0),
        this._adjustDialog(),
        this._setEscapeEvent(),
        this._setResizeEvent(),
        z.on(this._dialog, tG, () => {
          z.one(this._element, t4, (t) => {
            t.target === this._element && (this._ignoreBackdropClick = !0);
          });
        }),
        this._showBackdrop(() => this._showElement(t)));
    }
    hide() {
      if (!this._isShown || this._isTransitioning) return;
      let t = z.trigger(this._element, tK);
      if (t.defaultPrevented) return;
      this._isShown = !1;
      let e = this._isAnimated();
      e && (this._isTransitioning = !0),
        this._setEscapeEvent(),
        this._setResizeEvent(),
        this._focustrap.deactivate(),
        this._element.classList.remove(t6),
        z.off(this._element, t3),
        z.off(this._dialog, tG),
        this._queueCallback(() => this._hideModal(), this._element, e);
    }
    dispose() {
      [window, this._dialog].forEach((t) => z.off(t, tW)),
        this._backdrop.dispose(),
        this._focustrap.deactivate(),
        super.dispose();
    }
    handleUpdate() {
      this._adjustDialog();
    }
    _initializeBackDrop() {
      return new t_({
        isVisible: Boolean(this._config.backdrop),
        isAnimated: this._isAnimated(),
      });
    }
    _initializeFocusTrap() {
      return new tB({ trapElement: this._element });
    }
    _getConfig(t) {
      return (
        c(
          tF,
          (t = {
            ...tq,
            ...J.getDataAttributes(this._element),
            ...("object" == typeof t ? t : {}),
          }),
          tU
        ),
        t
      );
    }
    _showElement(t) {
      let e = this._isAnimated(),
        i = tt.findOne(".modal-body", this._dialog);
      (this._element.parentNode &&
        this._element.parentNode.nodeType === Node.ELEMENT_NODE) ||
        document.body.append(this._element),
        (this._element.style.display = "block"),
        this._element.removeAttribute("aria-hidden"),
        this._element.setAttribute("aria-modal", !0),
        this._element.setAttribute("role", "dialog"),
        (this._element.scrollTop = 0),
        i && (i.scrollTop = 0),
        e && m(this._element),
        this._element.classList.add(t6);
      let s = () => {
        this._config.focus && this._focustrap.activate(),
          (this._isTransitioning = !1),
          z.trigger(this._element, tQ, { relatedTarget: t });
      };
      this._queueCallback(s, this._dialog, e);
    }
    _setEscapeEvent() {
      this._isShown
        ? z.on(this._element, t2, (t) => {
            this._config.keyboard && t.key === tR
              ? (t.preventDefault(), this.hide())
              : this._config.keyboard ||
                t.key !== tR ||
                this._triggerBackdropTransition();
          })
        : z.off(this._element, t2);
    }
    _setResizeEvent() {
      this._isShown
        ? z.on(window, t1, () => this._adjustDialog())
        : z.off(window, t1);
    }
    _hideModal() {
      (this._element.style.display = "none"),
        this._element.setAttribute("aria-hidden", !0),
        this._element.removeAttribute("aria-modal"),
        this._element.removeAttribute("role"),
        (this._isTransitioning = !1),
        this._backdrop.hide(() => {
          document.body.classList.remove(t0),
            this._resetAdjustments(),
            this._scrollBar.reset(),
            z.trigger(this._element, tX);
        });
    }
    _showBackdrop(t) {
      z.on(this._element, t3, (t) => {
        if (this._ignoreBackdropClick) {
          this._ignoreBackdropClick = !1;
          return;
        }
        t.target === t.currentTarget &&
          (!0 === this._config.backdrop
            ? this.hide()
            : "static" === this._config.backdrop &&
              this._triggerBackdropTransition());
      }),
        this._backdrop.show(t);
    }
    _isAnimated() {
      return this._element.classList.contains("fade");
    }
    _triggerBackdropTransition() {
      let t = z.trigger(this._element, tV);
      if (t.defaultPrevented) return;
      let { classList: e, scrollHeight: i, style: s } = this._element,
        n = i > document.documentElement.clientHeight;
      !((!n && "hidden" === s.overflowY) || e.contains(tJ)) &&
        (n || (s.overflowY = "hidden"),
        e.add(tJ),
        this._queueCallback(() => {
          e.remove(tJ),
            n ||
              this._queueCallback(() => {
                s.overflowY = "";
              }, this._dialog);
        }, this._dialog),
        this._element.focus());
    }
    _adjustDialog() {
      let t =
          this._element.scrollHeight > document.documentElement.clientHeight,
        e = this._scrollBar.getWidth(),
        i = e > 0;
      ((!i && t && !E()) || (i && !t && E())) &&
        (this._element.style.paddingLeft = `${e}px`),
        ((i && !t && !E()) || (!i && t && E())) &&
          (this._element.style.paddingRight = `${e}px`);
    }
    _resetAdjustments() {
      (this._element.style.paddingLeft = ""),
        (this._element.style.paddingRight = "");
    }
    static jQueryInterface(t, e) {
      return this.each(function () {
        let i = t5.getOrCreateInstance(this, t);
        if ("string" == typeof t) {
          if (void 0 === i[t]) throw TypeError(`No method named "${t}"`);
          i[t](e);
        }
      });
    }
  }
  z.on(document, tZ, '[data-bs-toggle="modal"]', function (t) {
    let e = o(this);
    ["A", "AREA"].includes(this.tagName) && t.preventDefault(),
      z.one(e, tY, (t) => {
        !t.defaultPrevented &&
          z.one(e, tX, () => {
            d(this) && this.focus();
          });
      });
    let i = tt.findOne(".modal.show");
    i && t5.getInstance(i).hide();
    let s = t5.getOrCreateInstance(e);
    s.toggle(this);
  }),
    R(t5),
    y(t5);
  let t7 = "offcanvas",
    et = ".bs.offcanvas",
    ee = ".data-api",
    ei = `load${et}${ee}`,
    es = { backdrop: !0, keyboard: !0, scroll: !1 },
    en = { backdrop: "boolean", keyboard: "boolean", scroll: "boolean" },
    eo = "show",
    er = ".offcanvas.show",
    el = `show${et}`,
    ea = `shown${et}`,
    eh = `hide${et}`,
    ec = `hidden${et}`,
    ed = `click${et}${ee}`,
    eu = `keydown.dismiss${et}`;
  class e8 extends W {
    constructor(t, e) {
      super(t),
        (this._config = this._getConfig(e)),
        (this._isShown = !1),
        (this._backdrop = this._initializeBackDrop()),
        (this._focustrap = this._initializeFocusTrap()),
        this._addEventListeners();
    }
    static get NAME() {
      return t7;
    }
    static get Default() {
      return es;
    }
    toggle(t) {
      return this._isShown ? this.hide() : this.show(t);
    }
    show(t) {
      if (this._isShown) return;
      let e = z.trigger(this._element, el, { relatedTarget: t });
      if (e.defaultPrevented) return;
      (this._isShown = !0),
        (this._element.style.visibility = "visible"),
        this._backdrop.show(),
        this._config.scroll || new tL().hide(),
        this._element.removeAttribute("aria-hidden"),
        this._element.setAttribute("aria-modal", !0),
        this._element.setAttribute("role", "dialog"),
        this._element.classList.add(eo);
      let i = () => {
        this._config.scroll || this._focustrap.activate(),
          z.trigger(this._element, ea, { relatedTarget: t });
      };
      this._queueCallback(i, this._element, !0);
    }
    hide() {
      if (!this._isShown) return;
      let t = z.trigger(this._element, eh);
      if (t.defaultPrevented) return;
      this._focustrap.deactivate(),
        this._element.blur(),
        (this._isShown = !1),
        this._element.classList.remove(eo),
        this._backdrop.hide();
      let e = () => {
        this._element.setAttribute("aria-hidden", !0),
          this._element.removeAttribute("aria-modal"),
          this._element.removeAttribute("role"),
          (this._element.style.visibility = "hidden"),
          this._config.scroll || new tL().reset(),
          z.trigger(this._element, ec);
      };
      this._queueCallback(e, this._element, !0);
    }
    dispose() {
      this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose();
    }
    _getConfig(t) {
      return (
        c(
          t7,
          (t = {
            ...es,
            ...J.getDataAttributes(this._element),
            ...("object" == typeof t ? t : {}),
          }),
          en
        ),
        t
      );
    }
    _initializeBackDrop() {
      return new t_({
        className: "offcanvas-backdrop",
        isVisible: this._config.backdrop,
        isAnimated: !0,
        rootElement: this._element.parentNode,
        clickCallback: () => this.hide(),
      });
    }
    _initializeFocusTrap() {
      return new tB({ trapElement: this._element });
    }
    _addEventListeners() {
      z.on(this._element, eu, (t) => {
        this._config.keyboard && "Escape" === t.key && this.hide();
      });
    }
    static jQueryInterface(t) {
      return this.each(function () {
        let e = e8.getOrCreateInstance(this, t);
        if ("string" == typeof t) {
          if (void 0 === e[t] || t.startsWith("_") || "constructor" === t)
            throw TypeError(`No method named "${t}"`);
          e[t](this);
        }
      });
    }
  }
  z.on(document, ed, '[data-bs-toggle="offcanvas"]', function (t) {
    let e = o(this);
    if ((["A", "AREA"].includes(this.tagName) && t.preventDefault(), u(this)))
      return;
    z.one(e, ec, () => {
      d(this) && this.focus();
    });
    let i = tt.findOne(er);
    i && i !== e && e8.getInstance(i).hide();
    let s = e8.getOrCreateInstance(e);
    s.toggle(this);
  }),
    z.on(window, ei, () =>
      tt.find(er).forEach((t) => e8.getOrCreateInstance(t).show())
    ),
    R(e8),
    y(e8);
  let eg = new Set([
      "background",
      "cite",
      "href",
      "itemtype",
      "longdesc",
      "poster",
      "src",
      "xlink:href",
    ]),
    ef = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i,
    em =
      /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i,
    ep = (t, e) => {
      let i = t.nodeName.toLowerCase();
      if (e.includes(i))
        return (
          !eg.has(i) || Boolean(ef.test(t.nodeValue) || em.test(t.nodeValue))
        );
      let s = e.filter((t) => t instanceof RegExp);
      for (let n = 0, o = s.length; n < o; n++) if (s[n].test(i)) return !0;
      return !1;
    };
  function ev(t, e, i) {
    if (!t.length) return t;
    if (i && "function" == typeof i) return i(t);
    let s = new window.DOMParser(),
      n = s.parseFromString(t, "text/html"),
      o = [].concat(...n.body.querySelectorAll("*"));
    for (let r = 0, l = o.length; r < l; r++) {
      let a = o[r],
        h = a.nodeName.toLowerCase();
      if (!Object.keys(e).includes(h)) {
        a.remove();
        continue;
      }
      let c = [].concat(...a.attributes),
        d = [].concat(e["*"] || [], e[h] || []);
      c.forEach((t) => {
        ep(t, d) || a.removeAttribute(t.nodeName);
      });
    }
    return n.body.innerHTML;
  }
  let eb = "tooltip",
    eE = ".bs.tooltip",
    ey = new Set(["sanitize", "allowList", "sanitizeFn"]),
    eA = {
      animation: "boolean",
      template: "string",
      title: "(string|element|function)",
      trigger: "string",
      delay: "(number|object)",
      html: "boolean",
      selector: "(string|boolean)",
      placement: "(string|function)",
      offset: "(array|string|function)",
      container: "(string|element|boolean)",
      fallbackPlacements: "array",
      boundary: "(string|element)",
      customClass: "(string|function)",
      sanitize: "boolean",
      sanitizeFn: "(null|function)",
      allowList: "object",
      popperConfig: "(null|object|function)",
    },
    ew = {
      AUTO: "auto",
      TOP: "top",
      RIGHT: E() ? "left" : "right",
      BOTTOM: "bottom",
      LEFT: E() ? "right" : "left",
    },
    eT = {
      animation: !0,
      template:
        '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
      trigger: "hover focus",
      title: "",
      delay: 0,
      html: !1,
      selector: !1,
      placement: "top",
      offset: [0, 0],
      container: !1,
      fallbackPlacements: ["top", "right", "bottom", "left"],
      boundary: "clippingParents",
      customClass: "",
      sanitize: !0,
      sanitizeFn: null,
      allowList: {
        "*": ["class", "dir", "id", "lang", "role", /^aria-[\w-]*$/i],
        a: ["target", "href", "title", "rel"],
        area: [],
        b: [],
        br: [],
        col: [],
        code: [],
        div: [],
        em: [],
        hr: [],
        h1: [],
        h2: [],
        h3: [],
        h4: [],
        h5: [],
        h6: [],
        i: [],
        img: ["src", "srcset", "alt", "title", "width", "height"],
        li: [],
        ol: [],
        p: [],
        pre: [],
        s: [],
        small: [],
        span: [],
        sub: [],
        sup: [],
        strong: [],
        u: [],
        ul: [],
      },
      popperConfig: null,
    },
    e$ = {
      HIDE: `hide${eE}`,
      HIDDEN: `hidden${eE}`,
      SHOW: `show${eE}`,
      SHOWN: `shown${eE}`,
      INSERTED: `inserted${eE}`,
      CLICK: `click${eE}`,
      FOCUSIN: `focusin${eE}`,
      FOCUSOUT: `focusout${eE}`,
      MOUSEENTER: `mouseenter${eE}`,
      MOUSELEAVE: `mouseleave${eE}`,
    },
    eC = "fade",
    ek = "show",
    e9 = "show",
    eL = ".tooltip-inner",
    eS = ".modal",
    eI = "hide.bs.modal",
    eO = "hover",
    eD = "focus";
  class eN extends W {
    constructor(t, e) {
      if ("undefined" == typeof Popper)
        throw TypeError(
          "Bootstrap's tooltips require Popper (https://popper.js.org)"
        );
      super(t),
        (this._isEnabled = !0),
        (this._timeout = 0),
        (this._hoverState = ""),
        (this._activeTrigger = {}),
        (this._popper = null),
        (this._config = this._getConfig(e)),
        (this.tip = null),
        this._setListeners();
    }
    static get Default() {
      return eT;
    }
    static get NAME() {
      return eb;
    }
    static get Event() {
      return e$;
    }
    static get DefaultType() {
      return eA;
    }
    enable() {
      this._isEnabled = !0;
    }
    disable() {
      this._isEnabled = !1;
    }
    toggleEnabled() {
      this._isEnabled = !this._isEnabled;
    }
    toggle(t) {
      if (this._isEnabled) {
        if (t) {
          let e = this._initializeOnDelegatedTarget(t);
          (e._activeTrigger.click = !e._activeTrigger.click),
            e._isWithActiveTrigger() ? e._enter(null, e) : e._leave(null, e);
        } else {
          if (this.getTipElement().classList.contains(ek)) {
            this._leave(null, this);
            return;
          }
          this._enter(null, this);
        }
      }
    }
    dispose() {
      clearTimeout(this._timeout),
        z.off(this._element.closest(eS), eI, this._hideModalHandler),
        this.tip && this.tip.remove(),
        this._disposePopper(),
        super.dispose();
    }
    show() {
      if ("none" === this._element.style.display)
        throw Error("Please use show on visible elements");
      if (!(this.isWithContent() && this._isEnabled)) return;
      let t = z.trigger(this._element, this.constructor.Event.SHOW),
        e = g(this._element),
        s =
          null === e
            ? this._element.ownerDocument.documentElement.contains(
                this._element
              )
            : e.contains(this._element);
      if (t.defaultPrevented || !s) return;
      "tooltip" === this.constructor.NAME &&
        this.tip &&
        this.getTitle() !== this.tip.querySelector(eL).innerHTML &&
        (this._disposePopper(), this.tip.remove(), (this.tip = null));
      let n = this.getTipElement(),
        o = i(this.constructor.NAME);
      n.setAttribute("id", o),
        this._element.setAttribute("aria-describedby", o),
        this._config.animation && n.classList.add(eC);
      let r =
          "function" == typeof this._config.placement
            ? this._config.placement.call(this, n, this._element)
            : this._config.placement,
        l = this._getAttachment(r);
      this._addAttachmentClass(l);
      let { container: a } = this._config;
      F.set(n, this.constructor.DATA_KEY, this),
        this._element.ownerDocument.documentElement.contains(this.tip) ||
          (a.append(n),
          z.trigger(this._element, this.constructor.Event.INSERTED)),
        this._popper
          ? this._popper.update()
          : (this._popper = createPopper(
              this._element,
              n,
              this._getPopperConfig(l)
            )),
        n.classList.add(ek);
      let h = this._resolvePossibleFunction(this._config.customClass);
      h && n.classList.add(...h.split(" ")),
        "ontouchstart" in document.documentElement &&
          [].concat(...document.body.children).forEach((t) => {
            z.on(t, "mouseover", f);
          });
      let c = () => {
          let t = this._hoverState;
          (this._hoverState = null),
            z.trigger(this._element, this.constructor.Event.SHOWN),
            "out" === t && this._leave(null, this);
        },
        d = this.tip.classList.contains(eC);
      this._queueCallback(c, this.tip, d);
    }
    hide() {
      if (!this._popper) return;
      let t = this.getTipElement(),
        e = () => {
          !this._isWithActiveTrigger() &&
            (this._hoverState !== e9 && t.remove(),
            this._cleanTipClass(),
            this._element.removeAttribute("aria-describedby"),
            z.trigger(this._element, this.constructor.Event.HIDDEN),
            this._disposePopper());
        },
        i = z.trigger(this._element, this.constructor.Event.HIDE);
      if (i.defaultPrevented) return;
      t.classList.remove(ek),
        "ontouchstart" in document.documentElement &&
          []
            .concat(...document.body.children)
            .forEach((t) => z.off(t, "mouseover", f)),
        (this._activeTrigger.click = !1),
        (this._activeTrigger[eD] = !1),
        (this._activeTrigger[eO] = !1);
      let s = this.tip.classList.contains(eC);
      this._queueCallback(e, this.tip, s), (this._hoverState = "");
    }
    update() {
      null !== this._popper && this._popper.update();
    }
    isWithContent() {
      return Boolean(this.getTitle());
    }
    getTipElement() {
      if (this.tip) return this.tip;
      let t = document.createElement("div");
      t.innerHTML = this._config.template;
      let e = t.children[0];
      return (
        this.setContent(e), e.classList.remove(eC, ek), (this.tip = e), this.tip
      );
    }
    setContent(t) {
      this._sanitizeAndSetContent(t, this.getTitle(), eL);
    }
    _sanitizeAndSetContent(t, e, i) {
      let s = tt.findOne(i, t);
      if (!e && s) {
        s.remove();
        return;
      }
      this.setElementContent(s, e);
    }
    setElementContent(t, e) {
      if (null !== t) {
        if (a(e)) {
          (e = h(e)),
            this._config.html
              ? e.parentNode !== t && ((t.innerHTML = ""), t.append(e))
              : (t.textContent = e.textContent);
          return;
        }
        this._config.html
          ? (this._config.sanitize &&
              (e = ev(e, this._config.allowList, this._config.sanitizeFn)),
            (t.innerHTML = e))
          : (t.textContent = e);
      }
    }
    getTitle() {
      let t =
        this._element.getAttribute("data-bs-original-title") ||
        this._config.title;
      return this._resolvePossibleFunction(t);
    }
    updateAttachment(t) {
      return "right" === t ? "end" : "left" === t ? "start" : t;
    }
    _initializeOnDelegatedTarget(t, e) {
      return (
        e ||
        this.constructor.getOrCreateInstance(
          t.delegateTarget,
          this._getDelegateConfig()
        )
      );
    }
    _getOffset() {
      let { offset: t } = this._config;
      return "string" == typeof t
        ? t.split(",").map((t) => Number.parseInt(t, 10))
        : "function" == typeof t
        ? (e) => t(e, this._element)
        : t;
    }
    _resolvePossibleFunction(t) {
      return "function" == typeof t ? t.call(this._element) : t;
    }
    _getPopperConfig(t) {
      let e = {
        placement: t,
        modifiers: [
          {
            name: "flip",
            options: { fallbackPlacements: this._config.fallbackPlacements },
          },
          { name: "offset", options: { offset: this._getOffset() } },
          {
            name: "preventOverflow",
            options: { boundary: this._config.boundary },
          },
          {
            name: "arrow",
            options: { element: `.${this.constructor.NAME}-arrow` },
          },
          {
            name: "onChange",
            enabled: !0,
            phase: "afterWrite",
            fn: (t) => this._handlePopperPlacementChange(t),
          },
        ],
        onFirstUpdate: (t) => {
          t.options.placement !== t.placement &&
            this._handlePopperPlacementChange(t);
        },
      };
      return {
        ...e,
        ...("function" == typeof this._config.popperConfig
          ? this._config.popperConfig(e)
          : this._config.popperConfig),
      };
    }
    _addAttachmentClass(t) {
      this.getTipElement().classList.add(
        `${this._getBasicClassPrefix()}-${this.updateAttachment(t)}`
      );
    }
    _getAttachment(t) {
      return ew[t.toUpperCase()];
    }
    _setListeners() {
      let t = this._config.trigger.split(" ");
      t.forEach((t) => {
        if ("click" === t)
          z.on(
            this._element,
            this.constructor.Event.CLICK,
            this._config.selector,
            (t) => this.toggle(t)
          );
        else if ("manual" !== t) {
          let e =
              t === eO
                ? this.constructor.Event.MOUSEENTER
                : this.constructor.Event.FOCUSIN,
            i =
              t === eO
                ? this.constructor.Event.MOUSELEAVE
                : this.constructor.Event.FOCUSOUT;
          z.on(this._element, e, this._config.selector, (t) => this._enter(t)),
            z.on(this._element, i, this._config.selector, (t) =>
              this._leave(t)
            );
        }
      }),
        (this._hideModalHandler = () => {
          this._element && this.hide();
        }),
        z.on(this._element.closest(eS), eI, this._hideModalHandler),
        this._config.selector
          ? (this._config = {
              ...this._config,
              trigger: "manual",
              selector: "",
            })
          : this._fixTitle();
    }
    _fixTitle() {
      let t = this._element.getAttribute("title"),
        e = typeof this._element.getAttribute("data-bs-original-title");
      (t || "string" !== e) &&
        (this._element.setAttribute("data-bs-original-title", t || ""),
        !t ||
          this._element.getAttribute("aria-label") ||
          this._element.textContent ||
          this._element.setAttribute("aria-label", t),
        this._element.setAttribute("title", ""));
    }
    _enter(t, e) {
      if (
        ((e = this._initializeOnDelegatedTarget(t, e)),
        t && (e._activeTrigger["focusin" === t.type ? eD : eO] = !0),
        e.getTipElement().classList.contains(ek) || e._hoverState === e9)
      ) {
        e._hoverState = e9;
        return;
      }
      if (
        (clearTimeout(e._timeout),
        (e._hoverState = e9),
        !e._config.delay || !e._config.delay.show)
      ) {
        e.show();
        return;
      }
      e._timeout = setTimeout(() => {
        e._hoverState === e9 && e.show();
      }, e._config.delay.show);
    }
    _leave(t, e) {
      if (
        ((e = this._initializeOnDelegatedTarget(t, e)),
        t &&
          (e._activeTrigger["focusout" === t.type ? eD : eO] =
            e._element.contains(t.relatedTarget)),
        !e._isWithActiveTrigger())
      ) {
        if (
          (clearTimeout(e._timeout),
          (e._hoverState = "out"),
          !e._config.delay || !e._config.delay.hide)
        ) {
          e.hide();
          return;
        }
        e._timeout = setTimeout(() => {
          "out" === e._hoverState && e.hide();
        }, e._config.delay.hide);
      }
    }
    _isWithActiveTrigger() {
      for (let t in this._activeTrigger) if (this._activeTrigger[t]) return !0;
      return !1;
    }
    _getConfig(t) {
      let e = J.getDataAttributes(this._element);
      return (
        Object.keys(e).forEach((t) => {
          ey.has(t) && delete e[t];
        }),
        ((t = {
          ...this.constructor.Default,
          ...e,
          ...("object" == typeof t && t ? t : {}),
        }).container = !1 === t.container ? document.body : h(t.container)),
        "number" == typeof t.delay &&
          (t.delay = { show: t.delay, hide: t.delay }),
        "number" == typeof t.title && (t.title = t.title.toString()),
        "number" == typeof t.content && (t.content = t.content.toString()),
        c(eb, t, this.constructor.DefaultType),
        t.sanitize && (t.template = ev(t.template, t.allowList, t.sanitizeFn)),
        t
      );
    }
    _getDelegateConfig() {
      let t = {};
      for (let e in this._config)
        this.constructor.Default[e] !== this._config[e] &&
          (t[e] = this._config[e]);
      return t;
    }
    _cleanTipClass() {
      let t = this.getTipElement(),
        e = RegExp(`(^|\\s)${this._getBasicClassPrefix()}\\S+`, "g"),
        i = t.getAttribute("class").match(e);
      null !== i &&
        i.length > 0 &&
        i.map((t) => t.trim()).forEach((e) => t.classList.remove(e));
    }
    _getBasicClassPrefix() {
      return "bs-tooltip";
    }
    _handlePopperPlacementChange(t) {
      let { state: e } = t;
      e &&
        ((this.tip = e.elements.popper),
        this._cleanTipClass(),
        this._addAttachmentClass(this._getAttachment(e.placement)));
    }
    _disposePopper() {
      this._popper && (this._popper.destroy(), (this._popper = null));
    }
    static jQueryInterface(t) {
      return this.each(function () {
        let e = eN.getOrCreateInstance(this, t);
        if ("string" == typeof t) {
          if (void 0 === e[t]) throw TypeError(`No method named "${t}"`);
          e[t]();
        }
      });
    }
  }
  y(eN);
  let e_ = ".bs.popover",
    ex = {
      ...eN.Default,
      placement: "right",
      offset: [0, 8],
      trigger: "click",
      content: "",
      template:
        '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>',
    },
    eP = { ...eN.DefaultType, content: "(string|element|function)" },
    eM = {
      HIDE: `hide${e_}`,
      HIDDEN: `hidden${e_}`,
      SHOW: `show${e_}`,
      SHOWN: `shown${e_}`,
      INSERTED: `inserted${e_}`,
      CLICK: `click${e_}`,
      FOCUSIN: `focusin${e_}`,
      FOCUSOUT: `focusout${e_}`,
      MOUSEENTER: `mouseenter${e_}`,
      MOUSELEAVE: `mouseleave${e_}`,
    };
  class eH extends eN {
    static get Default() {
      return ex;
    }
    static get NAME() {
      return "popover";
    }
    static get Event() {
      return eM;
    }
    static get DefaultType() {
      return eP;
    }
    isWithContent() {
      return this.getTitle() || this._getContent();
    }
    setContent(t) {
      this._sanitizeAndSetContent(t, this.getTitle(), ".popover-header"),
        this._sanitizeAndSetContent(t, this._getContent(), ".popover-body");
    }
    _getContent() {
      return this._resolvePossibleFunction(this._config.content);
    }
    _getBasicClassPrefix() {
      return "bs-popover";
    }
    static jQueryInterface(t) {
      return this.each(function () {
        let e = eH.getOrCreateInstance(this, t);
        if ("string" == typeof t) {
          if (void 0 === e[t]) throw TypeError(`No method named "${t}"`);
          e[t]();
        }
      });
    }
  }
  y(eH);
  let ej = "scrollspy",
    ez = ".bs.scrollspy",
    eB = { offset: 10, method: "auto", target: "" },
    eF = { offset: "number", method: "string", target: "(string|element)" },
    eW = `activate${ez}`,
    eR = `scroll${ez}`,
    eq = `load${ez}.data-api`,
    eU = "dropdown-item",
    eK = "active",
    eV = ".nav-link",
    eX = ".list-group-item",
    eY = `${eV}, ${eX}, .${eU}`,
    eQ = "position";
  class e1 extends W {
    constructor(t, e) {
      super(t),
        (this._scrollElement =
          "BODY" === this._element.tagName ? window : this._element),
        (this._config = this._getConfig(e)),
        (this._offsets = []),
        (this._targets = []),
        (this._activeTarget = null),
        (this._scrollHeight = 0),
        z.on(this._scrollElement, eR, () => this._process()),
        this.refresh(),
        this._process();
    }
    static get Default() {
      return eB;
    }
    static get NAME() {
      return ej;
    }
    refresh() {
      let t =
          this._scrollElement === this._scrollElement.window ? "offset" : eQ,
        e = "auto" === this._config.method ? t : this._config.method,
        i = e === eQ ? this._getScrollTop() : 0;
      (this._offsets = []),
        (this._targets = []),
        (this._scrollHeight = this._getScrollHeight());
      let s = tt.find(eY, this._config.target);
      s.map((t) => {
        let s = n(t),
          o = s ? tt.findOne(s) : null;
        if (o) {
          let r = o.getBoundingClientRect();
          if (r.width || r.height) return [J[e](o).top + i, s];
        }
        return null;
      })
        .filter((t) => t)
        .sort((t, e) => t[0] - e[0])
        .forEach((t) => {
          this._offsets.push(t[0]), this._targets.push(t[1]);
        });
    }
    dispose() {
      z.off(this._scrollElement, ez), super.dispose();
    }
    _getConfig(t) {
      return (
        ((t = {
          ...eB,
          ...J.getDataAttributes(this._element),
          ...("object" == typeof t && t ? t : {}),
        }).target = h(t.target) || document.documentElement),
        c(ej, t, eF),
        t
      );
    }
    _getScrollTop() {
      return this._scrollElement === window
        ? this._scrollElement.pageYOffset
        : this._scrollElement.scrollTop;
    }
    _getScrollHeight() {
      return (
        this._scrollElement.scrollHeight ||
        Math.max(
          document.body.scrollHeight,
          document.documentElement.scrollHeight
        )
      );
    }
    _getOffsetHeight() {
      return this._scrollElement === window
        ? window.innerHeight
        : this._scrollElement.getBoundingClientRect().height;
    }
    _process() {
      let t = this._getScrollTop() + this._config.offset,
        e = this._getScrollHeight(),
        i = this._config.offset + e - this._getOffsetHeight();
      if ((this._scrollHeight !== e && this.refresh(), t >= i)) {
        let s = this._targets[this._targets.length - 1];
        this._activeTarget !== s && this._activate(s);
        return;
      }
      if (this._activeTarget && t < this._offsets[0] && this._offsets[0] > 0) {
        (this._activeTarget = null), this._clear();
        return;
      }
      for (let n = this._offsets.length; n--; ) {
        let o =
          this._activeTarget !== this._targets[n] &&
          t >= this._offsets[n] &&
          (void 0 === this._offsets[n + 1] || t < this._offsets[n + 1]);
        o && this._activate(this._targets[n]);
      }
    }
    _activate(t) {
      (this._activeTarget = t), this._clear();
      let e = eY
          .split(",")
          .map((e) => `${e}[data-bs-target="${t}"],${e}[href="${t}"]`),
        i = tt.findOne(e.join(","), this._config.target);
      i.classList.add(eK),
        i.classList.contains(eU)
          ? tt
              .findOne(".dropdown-toggle", i.closest(".dropdown"))
              .classList.add(eK)
          : tt.parents(i, ".nav, .list-group").forEach((t) => {
              tt.prev(t, `${eV}, ${eX}`).forEach((t) => t.classList.add(eK)),
                tt.prev(t, ".nav-item").forEach((t) => {
                  tt.children(t, eV).forEach((t) => t.classList.add(eK));
                });
            }),
        z.trigger(this._scrollElement, eW, { relatedTarget: t });
    }
    _clear() {
      tt.find(eY, this._config.target)
        .filter((t) => t.classList.contains(eK))
        .forEach((t) => t.classList.remove(eK));
    }
    static jQueryInterface(t) {
      return this.each(function () {
        let e = e1.getOrCreateInstance(this, t);
        if ("string" == typeof t) {
          if (void 0 === e[t]) throw TypeError(`No method named "${t}"`);
          e[t]();
        }
      });
    }
  }
  z.on(window, eq, () => {
    tt.find('[data-bs-spy="scroll"]').forEach((t) => new e1(t));
  }),
    y(e1);
  let e3 = ".bs.tab",
    e2 = `hide${e3}`,
    e4 = `hidden${e3}`,
    eG = `show${e3}`,
    eZ = `shown${e3}`,
    e0 = `click${e3}.data-api`,
    e6 = "active",
    eJ = "fade",
    e5 = "show",
    e7 = ".active",
    it = ":scope > li > .active";
  class ie extends W {
    static get NAME() {
      return "tab";
    }
    show() {
      if (
        this._element.parentNode &&
        this._element.parentNode.nodeType === Node.ELEMENT_NODE &&
        this._element.classList.contains(e6)
      )
        return;
      let t,
        e = o(this._element),
        i = this._element.closest(".nav, .list-group");
      if (i) {
        let s = "UL" === i.nodeName || "OL" === i.nodeName ? it : e7;
        t = (t = tt.find(s, i))[t.length - 1];
      }
      let n = t ? z.trigger(t, e2, { relatedTarget: this._element }) : null,
        r = z.trigger(this._element, eG, { relatedTarget: t });
      if (r.defaultPrevented || (null !== n && n.defaultPrevented)) return;
      this._activate(this._element, i);
      let l = () => {
        z.trigger(t, e4, { relatedTarget: this._element }),
          z.trigger(this._element, eZ, { relatedTarget: t });
      };
      e ? this._activate(e, e.parentNode, l) : l();
    }
    _activate(t, e, i) {
      let s =
          e && ("UL" === e.nodeName || "OL" === e.nodeName)
            ? tt.find(it, e)
            : tt.children(e, e7),
        n = s[0],
        o = i && n && n.classList.contains(eJ),
        r = () => this._transitionComplete(t, n, i);
      n && o ? (n.classList.remove(e5), this._queueCallback(r, t, !0)) : r();
    }
    _transitionComplete(t, e, i) {
      if (e) {
        e.classList.remove(e6);
        let s = tt.findOne(":scope > .dropdown-menu .active", e.parentNode);
        s && s.classList.remove(e6),
          "tab" === e.getAttribute("role") &&
            e.setAttribute("aria-selected", !1);
      }
      t.classList.add(e6),
        "tab" === t.getAttribute("role") && t.setAttribute("aria-selected", !0),
        m(t),
        t.classList.contains(eJ) && t.classList.add(e5);
      let n = t.parentNode;
      if (
        (n && "LI" === n.nodeName && (n = n.parentNode),
        n && n.classList.contains("dropdown-menu"))
      ) {
        let o = t.closest(".dropdown");
        o && tt.find(".dropdown-toggle", o).forEach((t) => t.classList.add(e6)),
          t.setAttribute("aria-expanded", !0);
      }
      i && i();
    }
    static jQueryInterface(t) {
      return this.each(function () {
        let e = ie.getOrCreateInstance(this);
        if ("string" == typeof t) {
          if (void 0 === e[t]) throw TypeError(`No method named "${t}"`);
          e[t]();
        }
      });
    }
  }
  z.on(
    document,
    e0,
    '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]',
    function (t) {
      if ((["A", "AREA"].includes(this.tagName) && t.preventDefault(), u(this)))
        return;
      let e = ie.getOrCreateInstance(this);
      e.show();
    }
  ),
    y(ie);
  let ii = "toast",
    is = ".bs.toast",
    io = `mouseover${is}`,
    ir = `mouseout${is}`,
    il = `focusin${is}`,
    ia = `focusout${is}`,
    ih = `hide${is}`,
    ic = `hidden${is}`,
    id = `show${is}`,
    iu = `shown${is}`,
    i8 = "hide",
    ig = "show",
    im = "showing",
    ip = { animation: "boolean", autohide: "boolean", delay: "number" },
    iv = { animation: !0, autohide: !0, delay: 5e3 };
  class ib extends W {
    constructor(t, e) {
      super(t),
        (this._config = this._getConfig(e)),
        (this._timeout = null),
        (this._hasMouseInteraction = !1),
        (this._hasKeyboardInteraction = !1),
        this._setListeners();
    }
    static get DefaultType() {
      return ip;
    }
    static get Default() {
      return iv;
    }
    static get NAME() {
      return ii;
    }
    show() {
      let t = z.trigger(this._element, id);
      if (t.defaultPrevented) return;
      this._clearTimeout(),
        this._config.animation && this._element.classList.add("fade");
      let e = () => {
        this._element.classList.remove(im),
          z.trigger(this._element, iu),
          this._maybeScheduleHide();
      };
      this._element.classList.remove(i8),
        m(this._element),
        this._element.classList.add(ig),
        this._element.classList.add(im),
        this._queueCallback(e, this._element, this._config.animation);
    }
    hide() {
      if (!this._element.classList.contains(ig)) return;
      let t = z.trigger(this._element, ih);
      if (t.defaultPrevented) return;
      let e = () => {
        this._element.classList.add(i8),
          this._element.classList.remove(im),
          this._element.classList.remove(ig),
          z.trigger(this._element, ic);
      };
      this._element.classList.add(im),
        this._queueCallback(e, this._element, this._config.animation);
    }
    dispose() {
      this._clearTimeout(),
        this._element.classList.contains(ig) &&
          this._element.classList.remove(ig),
        super.dispose();
    }
    _getConfig(t) {
      return (
        c(
          ii,
          (t = {
            ...iv,
            ...J.getDataAttributes(this._element),
            ...("object" == typeof t && t ? t : {}),
          }),
          this.constructor.DefaultType
        ),
        t
      );
    }
    _maybeScheduleHide() {
      this._config.autohide &&
        !this._hasMouseInteraction &&
        !this._hasKeyboardInteraction &&
        (this._timeout = setTimeout(() => {
          this.hide();
        }, this._config.delay));
    }
    _onInteraction(t, e) {
      switch (t.type) {
        case "mouseover":
        case "mouseout":
          this._hasMouseInteraction = e;
          break;
        case "focusin":
        case "focusout":
          this._hasKeyboardInteraction = e;
      }
      if (e) {
        this._clearTimeout();
        return;
      }
      let i = t.relatedTarget;
      !(this._element === i || this._element.contains(i)) &&
        this._maybeScheduleHide();
    }
    _setListeners() {
      z.on(this._element, io, (t) => this._onInteraction(t, !0)),
        z.on(this._element, ir, (t) => this._onInteraction(t, !1)),
        z.on(this._element, il, (t) => this._onInteraction(t, !0)),
        z.on(this._element, ia, (t) => this._onInteraction(t, !1));
    }
    _clearTimeout() {
      clearTimeout(this._timeout), (this._timeout = null);
    }
    static jQueryInterface(t) {
      return this.each(function () {
        let e = ib.getOrCreateInstance(this, t);
        if ("string" == typeof t) {
          if (void 0 === e[t]) throw TypeError(`No method named "${t}"`);
          e[t](this);
        }
      });
    }
  }
  return (
    R(ib),
    y(ib),
    {
      Alert: V,
      Button: Q,
      Carousel: tC,
      Modal: t5,
      Offcanvas: e8,
      Popover: eH,
      ScrollSpy: e1,
      Tab: ie,
      Toast: ib,
      Tooltip: eN,
    }
  );
});
